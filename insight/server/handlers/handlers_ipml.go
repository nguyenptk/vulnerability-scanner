package server

import (
	"net/http"

	"github.com/nguyenptk/vulnerability-scanner/insight/server/insight/options"
	"github.com/nguyenptk/vulnerability-scanner/insight/storages"
)

// ReportHanlder implement the logic of /report endpoint
func (f *Insight) ReportHanlder(w http.ResponseWriter, req *http.Request) {

	// Init content-type
	w.Header().Set("content-type", "application/json")

	// Parse headers to Options
	opt, err := options.ParseHeaders(&req.Header)
	if err != nil {
		msg := "invalid header"
		w.WriteHeader(403)
		f.Logger.Info("%s. Error: %s\n", msg, err.Error())
		f.writeRespBody(w, "invalid header")
		return
	}

	queryCondition := &storages.QueryCondition{
		ID:     opt.ID,
		Offset: opt.Offset,
		Limit:  opt.Limit,
	}
	reportStorage := storages.ReportStorage{}

	// Get Report by ID
	if "" != queryCondition.ID {
		f.Logger.Debug("[%s] Get report by ID\n", opt.XRequestID)
		report := reportStorage.GetByID(f.MySQL, *queryCondition)
		if report != nil {
			w.WriteHeader(200)
			f.writeRespBody(w, report)
		} else {
			w.WriteHeader(404)
			f.writeRespBody(w, "invalid report id")
		}

	} else { // Get List of Reports
		f.Logger.Debug("[%s] Get list of reports\n", opt.XRequestID)
		reports := reportStorage.GetLists(f.MySQL, *queryCondition)
		if reports != nil && len(reports) > 0 {
			w.WriteHeader(200)
			metadata := &Metadata{
				Offset: options.IntPointer(opt.Offset),
				Limit:  options.IntPointer(opt.Limit),
				Count:  options.IntPointer(len(reports)),
			}
			f.writeRespBodyMetadata(w, reports, metadata)
		} else {
			w.WriteHeader(404)
			metadata := &Metadata{
				Offset: options.IntPointer(opt.Offset),
				Limit:  options.IntPointer(opt.Limit),
				Count:  options.IntPointer(0),
			}
			f.writeRespBodyMetadata(w, "report not found", metadata)
		}
	}
}
