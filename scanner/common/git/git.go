package git

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"

	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing"
	"gopkg.in/src-d/go-git.v4/plumbing/transport"
)

// CloneRepository clones a repository from a remote source to local temp. dir.
func CloneRepository(url *string, branch *string, depth int, auth transport.AuthMethod) (*git.Repository, string, error) {
	urlVal := *url
	branchVal := *branch
	dir, err := ioutil.TempDir("", "vulnerability_scanner")
	if err != nil {
		return nil, "", err
	}
	cloneOpt := &git.CloneOptions{
		URL:           urlVal,
		Depth:         depth,
		ReferenceName: plumbing.ReferenceName(fmt.Sprintf("refs/heads/%s", branchVal)),
		SingleBranch:  true,
		Tags:          git.NoTags,
	}
	if auth != nil {
		cloneOpt.Auth = auth
	}
	repository, err := git.PlainClone(dir, false, cloneOpt)
	if err != nil {
		return nil, dir, err
	}
	return repository, dir, nil
}

// GatherPaths gets all committed file paths
func GatherPaths(dir, branch string, targets []string) ([]string, error) {
	os.Chdir(dir)
	gitcmd := "git"
	listTree := "ls-tree"
	op1 := "-r"
	op2 := "--name-only"
	var paths []string

	if len(targets) == 0 {
		out, err := exec.Command(gitcmd, listTree, op1, branch, op2).CombinedOutput()
		if err != nil {
			return nil, err
		}
		cmdout := fmt.Sprintf("%s", strings.TrimSpace(string(out)))
		paths = append(paths, strings.Split(cmdout, "\n")...)
	}

	for _, t := range targets {
		out, err := exec.Command(gitcmd, listTree, op1, fmt.Sprintf("%s:%s", branch, t), op2).CombinedOutput()
		if err != nil {
			return nil, err
		}
		cmdout := fmt.Sprintf("%s", strings.TrimSpace(string(out)))
		currentPaths := strings.Split(cmdout, "\n")
		for i, p := range currentPaths {
			currentPaths[i] = path.Join(t, p)
		}
		paths = append(paths, currentPaths...)
	}
	return paths, nil
}
