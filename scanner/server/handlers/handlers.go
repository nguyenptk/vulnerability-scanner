package server

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	scanner "github.com/nguyenptk/vulnerability-scanner/scanner/server"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/gitprovider"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/options"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/session"
	"github.com/nguyenptk/vulnerability-scanner/scanner/storages"
)

func Scan(w http.ResponseWriter, req *http.Request) {
	// Parse headers to Options
	opt, err := options.ParseHeaders(req)
	if err != nil {
		w.WriteHeader(403)
		return
	}

	// Initialize new scan session
	sess := &session.Session{}
	sess.Initialize(opt)

	// Start the session
	// We can consider adding a queue to handle the load during the high traffic
	sess.Stats.QueueAt = time.Now()
	sess.Stats.QueueAt.Format(time.RFC3339)

	sess.Out.Important("[%s] %s Scanning Started at %s\n", sess.Options.XRequestID, strings.Title(gitprovider.GithubName), sess.Stats.StartedAt.Format(time.RFC3339))
	sess.Out.Important("[%s] Loaded %d signatures\n", sess.Options.XRequestID, len(sess.Signatures))

	// Set Git provider
	gitProvider := &gitprovider.GithubProvider{}
	if *opt.Token == "" {
		*opt.Token = os.Getenv(gitprovider.GithubParamToken)
	}

	// Init HTTP response
	w.Header().Set("Content-Type", "application/json")

	// Initialize Git provider
	err = gitProvider.Initialize(*opt.Token)
	if err != nil {
		msg := fmt.Sprintf("[%s] Unable to initialise %s provider", sess.Options.XRequestID, gitprovider.GithubName)
		sess.Out.Error(msg)

		// Return status_code=401 & error message
		w.WriteHeader(401)
		writeRespBody(w, sess, msg)

		return
	}

	// Scan
	scannerErrors := scanner.Scan(sess, gitProvider)

	var result *storages.Result

	if scannerErrors != nil {
		writeRespBody(w, sess, scannerErrors)
	} else {
		sess.Out.Important("[%s] Gitlab Scanning Finished at %s\n", sess.Options.XRequestID, sess.Stats.FinishedAt.Format(time.RFC3339))
		sess.Stats.Status = session.StatusSuccess
		if sess.Vulnerabilities != nil {
			result = storages.ConvertToResult(sess)
			writeRespBody(w, sess, result)
		} else {
			writeRespBody(w, sess, "No vulnerability")
		}
	}

	// Print stats
	sess.Stats.PrintStats(sess.Out)

	// Save findings to the storage & considering put them to a queue for async
	// that helps decrease the workload of databases during the high traffic time

}

func writeRespBody(w http.ResponseWriter, sess *session.Session, v interface{}) {
	resp := make(map[string]interface{})
	resp["message"] = v
	result, err := json.Marshal(resp)
	if err != nil {
		sess.Out.Error("[%s] Error happened in JSON marshal. Err: %s", sess.Options.XRequestID, err)
	}
	w.Write(result)
}
