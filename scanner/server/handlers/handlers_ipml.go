package server

import (
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	scanner "github.com/nguyenptk/vulnerability-scanner/scanner/server"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/gitprovider"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/options"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/session"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/vulnerabilities"
	"github.com/nguyenptk/vulnerability-scanner/scanner/storages"
)

// ScanHanlder implement the logic of /scan endpoint
func (f *Scanner) ScanHanlder(w http.ResponseWriter, req *http.Request) {
	// Parse headers to Options
	opt, err := options.ParseHeaders(req)
	if err != nil {
		w.WriteHeader(403)
		return
	}

	// Initialize new scan session
	sess := &session.Session{}
	sess.Initialize(opt)
	// Initialize logger for session
	sess.Out = f.Logger

	// Start the session
	// We can consider adding a queue to handle the load during the high traffic
	sess.Stats.QueueAt = time.Now()
	sess.Stats.QueueAt.Format(time.RFC3339)

	sess.Out.Important("[%s] %s Scanning Started at %s\n", sess.Options.XRequestID, strings.Title(gitprovider.GithubName), sess.Stats.StartedAt.Format(time.RFC3339))
	sess.Out.Important("[%s] Loaded %d signatures\n", sess.Options.XRequestID, len(sess.Signatures))

	// Set Git provider
	gitProvider := &gitprovider.GithubProvider{}
	if opt.Token == "" {
		opt.Token = os.Getenv(gitprovider.GithubParamToken)
	}

	// Init HTTP response
	w.Header().Set("Content-Type", "application/json")

	// Initialize Git provider
	err = gitProvider.Initialize(opt.Token)
	if err != nil {
		msg := fmt.Sprintf("[%s] Unable to initialise %s provider\n", sess.Options.XRequestID, gitprovider.GithubName)
		sess.Out.Error(msg)

		// Return status_code=401 & error message
		w.WriteHeader(401)
		f.writeRespBody(w, sess, msg)

		return
	}

	// Scan
	scannerErrors := scanner.Scan(sess, gitProvider)

	// Initialize result for client response
	var result *vulnerabilities.Result

	if scannerErrors != nil {
		f.writeRespBody(w, sess, scannerErrors)
	} else {
		sess.Out.Important("[%s] Gitlab Scanning Finished at %s\n", sess.Options.XRequestID, sess.Stats.FinishedAt.Format(time.RFC3339))
		sess.Stats.Status = session.StatusSuccess
		if sess.Vulnerabilities != nil {
			result = sess.ConvertSessToResult()
			f.writeRespBody(w, sess, result)
		} else {
			f.writeRespBody(w, sess, "No vulnerability")
		}
	}

	// Print stats
	sess.Stats.PrintStats(sess.Out)

	// Save result to the storage & considering put them to a queue for async
	// that helps decrease the workload of storage during the high traffic time
	// Example: saga pattern :thinking:

	/*
		I'm trying to use gorm to insert the hole *vulnerabilities.Result with `foreignkey:id`
		but it cannot insert multi rows for Findings.
		So I separated them here and I'll try again later
	*/

	if result != nil {
		// Insert Report
		sess.Out.Debug("Insert report to reports table\n")
		reportStorage := storages.ReportStorage{}
		reportStorage.Insert(f.MySQL, result)

		// Insert Vulnerabilities
		sess.Out.Debug("Insert vulnerabilities to vulnerabilities table\n")
		vulnerabilityStorage := storages.VulnerabilityStorage{}
		vulnerabilityStorage.Insert(f.MySQL, result)

		// Insert Findings
		sess.Out.Debug("Insert findings to findings table\n")
		findingStorage := storages.FindingStorage{}
		findingStorage.Insert(f.MySQL, result)
	}
}
