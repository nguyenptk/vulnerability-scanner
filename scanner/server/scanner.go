package scanner

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"regexp"
	"strings"
	"sync"

	"gopkg.in/src-d/go-git.v4/plumbing/transport/http"

	gitHandler "github.com/nguyenptk/vulnerability-scanner/scanner/common/git"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/findings"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/gitprovider"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/session"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/signatures"
	"gopkg.in/src-d/go-git.v4"
)

// NewlineRegex ...
var NewlineRegex = regexp.MustCompile(`\r?\n`)

// Scan starts the scanning process
func Scan(sess *session.Session, gitProvider gitprovider.GitProvider) {
	gatherRepositories(sess, gitProvider)

	sess.Stats.Status = session.StatusInProgress
	var ch = make(chan *gitprovider.Repository, len(sess.Repositories))
	var wg sync.WaitGroup
	var threadNum int
	if len(sess.Repositories) <= 1 {
		threadNum = 1
	} else if len(sess.Repositories) <= *sess.Options.Threads {
		threadNum = len(sess.Repositories) - 1
	} else {
		threadNum = *sess.Options.Threads
	}
	wg.Add(threadNum)
	sess.Out.Debug("Threads for repository analysis: %d\n", threadNum)
	sess.Out.Important("Analyzing %d %s...\n", len(sess.Repositories), Pluralize(len(sess.Repositories), "repository", "repositories"))

	authMethod := &http.BasicAuth{
		Username: "secretscanner",
		Password: *sess.Options.Token,
	}

	for i := 0; i < threadNum; i++ {
		go func(tid int) {
			for {
				sess.Out.Debug("[THREAD #%d] Requesting new repository to analyze...\n", tid)
				repo, ok := <-ch
				if !ok {
					sess.Out.Debug("[THREAD #%d] No more tasks, marking WaitGroup as done\n", tid)
					wg.Done()
					return
				}

				// Clone repo
				sess.Out.Debug("[THREAD #%d][%s] Cloning repository...\n", tid, repo.FullName)
				// CommitDepth = 500
				clone, cloneDir, err := gitHandler.CloneRepository(&repo.CloneURL, &repo.DefaultBranch, 500, authMethod)
				if err != nil {
					if err.Error() != "Remote repository is empty" {
						sess.Out.Error("Error cloning repository %s: %s\n", repo.FullName, err)
					}
					sess.Stats.IncrementRepositories()
					sess.Stats.UpdateProgress(sess.Stats.Repositories, len(sess.Repositories))
					continue
				}
				sess.Out.Debug("[THREAD #%d][%s] Cloned repository to: %s\n", tid, repo.FullName, cloneDir)

				// Get checkpoint
				sess.Out.Debug("[THREAD #%d][%s] Fetching the checkpoint.\n", tid, repo.FullName)
				checkpoint := ""

				// Gather scan targets
				targets := sess.Options.ParseScanTargets()
				targetPaths, err := gitHandler.GatherPaths(cloneDir, repo.DefaultBranch, targets)
				if err != nil {
					sess.Out.Error("Failed to gather target paths for repo: %v", repo.FullName)
					return
				}

				targetPathMap := map[string]string{}
				for _, tp := range targetPaths {
					targetPathMap[path.Join(cloneDir, tp)] = tp
				}

				// Scan
				scanRevisions(sess, repo, clone, checkpoint, cloneDir, targetPathMap)

				// Cleanup
				sess.Out.Debug("[THREAD #%d][%s] Done analyzing commits\n", tid, repo.FullName)
				_ = os.RemoveAll(cloneDir)
				sess.Out.Debug("[THREAD #%d][%s] Deleted %s\n", tid, repo.FullName, cloneDir)
				sess.Stats.IncrementRepositories()
				sess.Stats.UpdateProgress(sess.Stats.Repositories, len(sess.Repositories))
			}
		}(i)
	}
	for _, repo := range sess.Repositories {
		ch <- repo
	}
	close(ch)
	wg.Wait()

	sess.End()
}

func gatherRepositories(sess *session.Session, gitProvider gitprovider.GitProvider) {
	var repos []*gitprovider.Repository

	if *sess.Options.Repos != "" {
		ids := strings.Split(*sess.Options.Repos, ",")
		for _, id := range ids {
			opt := map[string]string{}
			if gitProvider.Name() == gitprovider.GithubName {
				idParts := strings.Split(id, "/")
				if len(idParts) != 2 {
					sess.Out.Error("Wrong Github option format (owner/repo): %v\n", errors.New("wrong Github option format"))
					continue
				}
				opt["owner"] = idParts[0]
				opt["repo"] = idParts[1]
			} else {
				opt["id"] = id
			}
			r, err := gitProvider.GetRepository(opt)
			if err != nil {
				sess.Out.Error("Error fetching the repo with ID %s: %s\n", id, err)
				continue
			}
			repos = append(repos, r)
		}
	}
	for _, repo := range repos {
		sess.Out.Info(" Retrieved repository: %s\n", repo.FullName)
		sess.AddRepository(repo)
	}
	sess.Stats.IncrementTargets()
	sess.Out.Info(" Retrieved %d %s from %s\n", len(repos), Pluralize(len(repos), "repository", "repositories"), gitprovider.GithubName)
}

// It scans only the lastest revision. rather than scanning the entire commit history
func scanRevisions(sess *session.Session, repo *gitprovider.Repository, clone *git.Repository, checkpoint, cloneDir string, targetPathMap map[string]string) {
	sess.Out.Debug("[THREAD][%s] Fetching repository files of: %s\n", repo.FullName, cloneDir)
	for absPath, subPath := range targetPathMap {
		sess.Out.Debug("Path: %s\n", absPath)
		content, err := ioutil.ReadFile(absPath)
		if err != nil {
			sess.Out.Error("[FILE NOT FOUND]: %s\n", absPath)
			continue
		}
		matchFile := signatures.NewMatchFile(subPath, string(content))
		if matchFile.IsSkippable() {
			sess.Out.Debug("[THREAD][%s] Skipping %s\n", repo.FullName, matchFile.Path)
			continue
		}
		isTestContext := matchFile.IsTestContext()
		sess.Out.Debug("[THREAD][%s] Matching: %s...\n", repo.FullName, matchFile.Path)
		for _, signature := range sess.Signatures {
			matches := signature.Match(matchFile)

			for _, match := range matches {
				finding := &findings.Finding{
					FilePath:       subPath,
					Action:         signature.Part(),
					Description:    signature.Description(),
					Comment:        signature.Comment(),
					RepositoryName: repo.Name,
					RepositoryURL:  repo.URL,
					FileURL:        fmt.Sprintf("%s/blob/%s/%s", repo.URL, repo.DefaultBranch, subPath),
					Line:           match.Line,
					IsTestContext:  isTestContext,
				}

				hashID, err := finding.GenerateHashID()
				if err != nil {
					sess.Out.Error("Unable to generate hash ID for %v, skipping...", finding.FileURL)
					continue
				}
				finding.ID = hashID

				sess.AddFinding(finding)

				sess.Out.Warn(" %s: %s\n", strings.ToUpper(session.PathScan), finding.Description)
				sess.Out.Info("  Path........: %s\n", finding.FilePath)
				sess.Out.Info("  Repo........: %s\n", repo.FullName)
				sess.Out.Info("  Comment.....: %s\n", finding.Comment)
				sess.Out.Info("  File URL....: %s\n", finding.FileURL)
				sess.Out.Info("  Line........: %v\n", finding.Line)
				sess.Out.Info(" ------------------------------------------------\n\n")
				sess.Stats.IncrementFindings()
			}
		}
	}
}

// Pluralize makes word plural
func Pluralize(count int, singular string, plural string) string {
	if count == 1 {
		return singular
	}
	return plural
}

// TruncateString truncates string from whitespace pre/suf-fix
func TruncateString(str string, maxLength int) string {
	str = NewlineRegex.ReplaceAllString(str, " ")
	str = strings.TrimSpace(str)
	if len(str) > maxLength {
		str = fmt.Sprintf("%s...", str[0:maxLength])
	}
	return str
}
