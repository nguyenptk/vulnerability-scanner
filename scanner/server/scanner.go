package scanner

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"sync"

	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing/transport/http"

	gitHandler "github.com/nguyenptk/vulnerability-scanner/scanner/common/git"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/gitprovider"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/session"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/signatures"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/vulnerabilities"
)

// ScannerError
type ScannerError struct {
	Code int
	Msg  string
}

// Scan starts the scanning process
func Scan(sess *session.Session, gitProvider gitprovider.GitProvider) []ScannerError {
	var scannerErrors []ScannerError

	sess.Stats.Status = session.StatusInProgress

	// Gather Repos
	gatherErrors := gatherRepositories(sess, gitProvider)
	if gatherErrors != nil {
		scannerErrors = append(scannerErrors, gatherErrors...)
		sess.Stats.Status = session.StatusFailure
	}

	var ch = make(chan *gitprovider.Repository, len(sess.Repositories))
	var wg sync.WaitGroup
	var threadNum int
	if len(sess.Repositories) <= 1 {
		threadNum = 1
	} else if len(sess.Repositories) <= sess.Options.Threads {
		threadNum = len(sess.Repositories) - 1
	} else {
		threadNum = sess.Options.Threads
	}
	wg.Add(threadNum)
	sess.Out.Debug("[%s] Threads for repository analysis: %d\n", sess.Options.XRequestID, threadNum)
	sess.Out.Important("[%s] Analyzing %d %s...\n", sess.Options.XRequestID, len(sess.Repositories), Pluralize(len(sess.Repositories), "repository", "repositories"))

	authMethod := &http.BasicAuth{
		Username: "scanner",
		Password: sess.Options.Token,
	}

	for i := 0; i < threadNum; i++ {
		go func(tid int) {
			for {
				sess.Out.Debug("[%s][THREAD #%d] Requesting new repository to analyze...\n", sess.Options.XRequestID, tid)
				repo, ok := <-ch
				if !ok {
					sess.Out.Debug("[%s][THREAD #%d] No more tasks, marking WaitGroup as done\n", sess.Options.XRequestID, tid)
					wg.Done()
					return
				}

				// Clone repo
				sess.Out.Debug("[%s][THREAD #%d][%s] Cloning repository...\n", sess.Options.XRequestID, tid, repo.FullName)
				// CommitDepth = 500 -> Need to investigate more.
				clone, cloneDir, err := gitHandler.CloneRepository(&repo.CloneURL, &repo.DefaultBranch, 500, authMethod)
				if err != nil {
					if err.Error() != "Remote repository is empty" {
						msg := fmt.Sprintf("Error cloning repository %s: %s\n", repo.FullName, err)
						scannerErrors = append(scannerErrors, ScannerError{Code: 401, Msg: msg})
						sess.Out.Error("[%s] %s\n", sess.Options.XRequestID, msg)
						sess.Stats.Status = session.StatusFailure
					}
					sess.Stats.IncrementRepositories()
					sess.Stats.UpdateProgress(sess.Stats.Repositories, len(sess.Repositories))
					continue
				}
				sess.Out.Debug("[%s][THREAD #%d][%s] Cloned repository to: %s\n", sess.Options.XRequestID, tid, repo.FullName, cloneDir)

				// Get checkpoint
				sess.Out.Debug("[%s][THREAD #%d][%s] Fetching the checkpoint.\n", sess.Options.XRequestID, tid, repo.FullName)
				checkpoint := ""

				// Gather scan targets
				targets := sess.Options.ParseScanTargets()
				targetPaths, err := gitHandler.GatherPaths(cloneDir, repo.DefaultBranch, targets)
				if err != nil {
					msg := fmt.Sprintf("Failed to gather target paths for repo: %v", repo.FullName)
					scannerErrors = append(scannerErrors, ScannerError{Code: 403, Msg: msg})
					sess.Out.Error("[%s] %s", sess.Options.XRequestID, msg)
					sess.Stats.Status = session.StatusFailure
					continue
				}

				targetPathMap := map[string]string{}
				for _, tp := range targetPaths {
					targetPathMap[path.Join(cloneDir, tp)] = tp
				}

				// Init Vulnerability
				vulnerability := &vulnerabilities.Vulnerability{}

				// Generate ID and add it to Vulnerability
				vulnerHashID, err := vulnerability.GenerateHashID()
				if err != nil {
					msg := fmt.Sprintf("Unable to generate hash ID for %v, skipping...", vulnerability.RepositoryUrl)
					scannerErrors = append(scannerErrors, ScannerError{Code: 403, Msg: msg})
					sess.Out.Error("[%s] %s\n", sess.Options.XRequestID, msg)
					continue
				}
				vulnerability.ID = vulnerHashID
				vulnerability.RepositoryName = repo.FullName
				vulnerability.RepositoryUrl = repo.URL
				vulnerability.ReportID = sess.Options.XRequestID

				// Add Vulnerability to Session
				sess.Vulnerabilities = append(sess.Vulnerabilities, vulnerability)

				// Scan
				scanErrors := scanRevisions(sess, repo, clone, checkpoint, cloneDir, targetPathMap, vulnerability.ID)
				if scanErrors != nil {
					scannerErrors = append(scannerErrors, scanErrors...)
					sess.Stats.Status = session.StatusFailure
				}

				// Cleanup
				sess.Out.Debug("[%s][THREAD #%d][%s] Done analyzing commits\n", sess.Options.XRequestID, tid, repo.FullName)
				_ = os.RemoveAll(cloneDir)
				sess.Out.Debug("[%s][THREAD #%d][%s] Deleted %s\n", sess.Options.XRequestID, tid, repo.FullName, cloneDir)
				sess.Stats.IncrementRepositories()
				sess.Stats.UpdateProgress(sess.Stats.Repositories, len(sess.Repositories))
			}
		}(i)
	}
	for _, repo := range sess.Repositories {
		ch <- repo
	}
	close(ch)
	wg.Wait()

	// Call session end
	sess.End()

	return scannerErrors
}

func gatherRepositories(sess *session.Session, gitProvider gitprovider.GitProvider) []ScannerError {
	var scannerErrors []ScannerError

	var repos []*gitprovider.Repository

	if sess.Options.Repos != "" {
		ids := strings.Split(sess.Options.Repos, ",")
		for _, id := range ids {
			opt := map[string]string{}
			if gitProvider.Name() == gitprovider.GithubName {
				idParts := strings.Split(id, "/")
				if len(idParts) != 2 {
					msg := fmt.Sprintf("Wrong Github option format (owner/repo): %v\n", errors.New("wrong Github option format"))
					scannerErrors = append(scannerErrors, ScannerError{Code: 403, Msg: msg})
					sess.Out.Error("[%s] %s\n", sess.Options.XRequestID, msg)
					continue
				}
				opt["owner"] = idParts[0]
				opt["repo"] = idParts[1]
			} else {
				opt["id"] = id
			}
			r, err := gitProvider.GetRepository(opt)
			if err != nil {
				msg := fmt.Sprintf("Error fetching the repo with ID %s: %s\n", id, err)
				scannerErrors = append(scannerErrors, ScannerError{Code: 403, Msg: msg})
				sess.Out.Error("[%s] %s\n", sess.Options.XRequestID, msg)
				continue
			}
			repos = append(repos, r)
		}
	}
	for _, repo := range repos {
		sess.Out.Info("[%s] Retrieved repository: %s\n", sess.Options.XRequestID, repo.FullName)
		sess.AddRepository(repo)
	}
	sess.Stats.IncrementTargets()
	sess.Out.Info("[%s] Retrieved %d %s from %s\n", sess.Options.XRequestID, len(repos), Pluralize(len(repos), "repository", "repositories"), gitprovider.GithubName)

	return scannerErrors
}

// It scans only the lastest revision. rather than scanning the entire commit history
func scanRevisions(sess *session.Session, repo *gitprovider.Repository, clone *git.Repository, checkpoint,
	cloneDir string, targetPathMap map[string]string, vulID string) []ScannerError {

	var scannerErrors []ScannerError

	sess.Out.Debug("[%s][THREAD][%s] Fetching repository files of: %s\n", sess.Options.XRequestID, repo.FullName, cloneDir)
	for absPath, subPath := range targetPathMap {
		sess.Out.Debug("[%s] Path: %s\n", sess.Options.XRequestID, absPath)
		content, err := ioutil.ReadFile(absPath)
		if err != nil {
			msg := fmt.Sprintf("[FILE NOT FOUND]: %s\n", absPath)
			scannerErrors = append(scannerErrors, ScannerError{Code: 403, Msg: msg})
			sess.Out.Error(msg)
			continue
		}
		matchFile := signatures.NewMatchFile(subPath, string(content))
		if matchFile.IsSkippable() {
			sess.Out.Debug("[%s][THREAD][%s] Skipping %s\n", sess.Options.XRequestID, repo.FullName, matchFile.Path)
			continue
		}
		sess.Out.Debug("[%s][THREAD][%s] Matching: %s...\n", sess.Options.XRequestID, repo.FullName, matchFile.Path)
		for _, signature := range sess.Signatures {
			matches := signature.Match(matchFile)

			for _, match := range matches {
				finding := &vulnerabilities.Finding{
					FilePath:    subPath,
					Action:      signature.Part(),
					Description: signature.Description(),
					Comment:     signature.Comment(),
					FileURL:     fmt.Sprintf("%s/blob/%s/%s", repo.URL, repo.DefaultBranch, subPath),
					Line:        match.Line,
				}
				// Generate ID and add it to Finding
				findingHashID, err := finding.GenerateHashID()
				if err != nil {
					msg := fmt.Sprintf("Unable to generate hash ID for %v, skipping...", finding.FileURL)
					scannerErrors = append(scannerErrors, ScannerError{Code: 403, Msg: msg})
					sess.Out.Error("[%s] %s", sess.Options.XRequestID, msg)
					continue
				}
				finding.ID = findingHashID

				// Get Vulnerability by ID and add Finding to it
				vul := sess.GetVulnerabilityByID(vulID)
				if vul != nil {

					// Set VulnerabilityID for Finding
					finding.VulnerabilityID = vul.ID

					vul.Findings = append(vul.Findings, finding)

					sess.Out.Warn(" %s: %s\n", strings.ToUpper(session.PathScan), finding.Description)
					sess.Out.Info("  Path........: %s\n", finding.FilePath)
					sess.Out.Info("  Repo........: %s\n", repo.FullName)
					sess.Out.Info("  Comment.....: %s\n", finding.Comment)
					sess.Out.Info("  File URL....: %s\n", finding.FileURL)
					sess.Out.Info("  Line........: %v\n", finding.Line)
					sess.Out.Info(" ------------------------------------------------\n\n")
					sess.Stats.IncrementFindings()
				}
			}
		}
	}
	return scannerErrors
}

// Pluralize makes word plural
func Pluralize(count int, singular string, plural string) string {
	if count == 1 {
		return singular
	}
	return plural
}
