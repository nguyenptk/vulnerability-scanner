/*
 * Copyright 2019 Grabtaxi Holdings PTE LTE (GRAB), All rights reserved.
 * Use of this source code is governed by an MIT-style license that can be found in the LICENSE file
 */

package session

import (
	"runtime"
	"sync"
	"time"

	"github.com/nguyenptk/vulnerability-scanner/scanner/common/log"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/gitprovider"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/options"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/signatures"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/stats"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/vulnerabilities"
)

// Session contains fields describing a scan session
type Session struct {
	sync.Mutex

	Options         *options.Options `json:"-"`
	Out             *log.Logger      `json:"-"`
	Stats           *stats.Stats
	Vulnerabilities []*vulnerabilities.Vulnerability
	Repositories    []*gitprovider.Repository
	Signatures      []signatures.Signature `json:"-"`
}

// Initialize inits a scan session
func (s *Session) Initialize(options *options.Options) {
	s.Options = options
	s.InitStats()
	s.Signatures = signatures.LoadSignatures()
}

// End end a scan session
func (s *Session) End() {
	s.Stats.FinishedAt = time.Now()
	s.Stats.Status = StatusSuccess
}

// InitStats inits stats
func (s *Session) InitStats() {
	s.Stats = &stats.Stats{
		StartedAt:    time.Now(),
		Status:       StatusQueued,
		Progress:     0.0,
		Targets:      0,
		Repositories: 0,
		Findings:     0,
	}
}

// InitThreads inits threads
func (s *Session) InitThreads() {
	if s.Options.Threads == 0 {
		numCPUs := runtime.NumCPU()
		s.Options.Threads = numCPUs
	}
	runtime.GOMAXPROCS(s.Options.Threads + 2) // thread count + main + web server
}

// AddVulnerability adds a Vulnerability
func (s *Session) AddVulnerability(vulnerability *vulnerabilities.Vulnerability) {
	s.Lock()
	defer s.Unlock()
	s.Vulnerabilities = append(s.Vulnerabilities, vulnerability)
}

// AddRepository adds a repo
func (s *Session) AddRepository(repository *gitprovider.Repository) {
	s.Lock()
	defer s.Unlock()
	for _, r := range s.Repositories {
		if repository.ID == r.ID {
			return
		}
	}
	s.Repositories = append(s.Repositories, repository)
}

// GetVulnerabilityByID get a Vulnerability by ID
func (s *Session) GetVulnerabilityByID(ID string) *vulnerabilities.Vulnerability {
	s.Lock()
	defer s.Unlock()
	for _, v := range s.Vulnerabilities {
		if v.ID == ID {
			return v
		}
	}
	return nil
}

// ConvertSessToResult for client response
func (s *Session) ConvertSessToResult() *vulnerabilities.Result {
	return &vulnerabilities.Result{
		ID:              s.Options.XRequestID,
		QueueAt:         s.Stats.QueueAt,
		StartedAt:       s.Stats.StartedAt,
		FinishedAt:      s.Stats.FinishedAt,
		Status:          s.Stats.Status,
		Progress:        vulnerabilities.FloatPointer(s.Stats.Progress),
		Targets:         vulnerabilities.IntPointer(s.Stats.Targets),
		Repositories:    vulnerabilities.IntPointer(s.Stats.Repositories),
		Findings:        vulnerabilities.IntPointer(s.Stats.Findings),
		Vulnerabilities: s.Vulnerabilities,
	}
}
