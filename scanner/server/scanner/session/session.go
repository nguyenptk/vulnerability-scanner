/*
 * Copyright 2019 Grabtaxi Holdings PTE LTE (GRAB), All rights reserved.
 * Use of this source code is governed by an MIT-style license that can be found in the LICENSE file
 */

package session

import (
	"runtime"
	"sync"
	"time"

	"github.com/nguyenptk/vulnerability-scanner/scanner/common/log"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/findings"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/gitprovider"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/options"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/signatures"
	"github.com/nguyenptk/vulnerability-scanner/scanner/server/scanner/stats"
)

// Session contains fields describing a scan session
type Session struct {
	sync.Mutex

	Options      options.Options `json:"-"`
	Out          *log.Logger     `json:"-"`
	Stats        *stats.Stats
	Findings     []*findings.Finding
	Repositories []*gitprovider.Repository
	Signatures   []signatures.Signature `json:"-"`
}

// Initialize inits a scan session
func (s *Session) Initialize(options options.Options) {
	s.Options = options
	s.InitLogger()
	s.InitStats()
	s.Signatures = signatures.LoadSignatures()
}

// End end a scan session
func (s *Session) End() {
	s.Stats.FinishedAt = time.Now()
	s.Stats.Status = StatusSuccess
}

// InitLogger inits a logger
func (s *Session) InitLogger() {
	s.Out = &log.Logger{}
}

// InitStats inits stats
func (s *Session) InitStats() {
	s.Stats = &stats.Stats{
		StartedAt:    time.Now(),
		Status:       StatusQueued,
		Progress:     0.0,
		Targets:      0,
		Repositories: 0,
		Commits:      0,
		Files:        0,
		Findings:     0,
	}
}

// InitThreads inits threads
func (s *Session) InitThreads() {
	if *s.Options.Threads == 0 {
		numCPUs := runtime.NumCPU()
		s.Options.Threads = &numCPUs
	}
	runtime.GOMAXPROCS(*s.Options.Threads + 2) // thread count + main + web server
}

// AddFinding adds a finding
func (s *Session) AddFinding(finding *findings.Finding) {
	s.Lock()
	defer s.Unlock()
	s.Findings = append(s.Findings, finding)
}

// AddRepository adds a repo
func (s *Session) AddRepository(repository *gitprovider.Repository) {
	s.Lock()
	defer s.Unlock()
	for _, r := range s.Repositories {
		if repository.ID == r.ID {
			return
		}
	}
	s.Repositories = append(s.Repositories, repository)
}
